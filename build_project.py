import os
import re
import random

# Transform main code
def transform_main_code(code):
    replacements = {
        r'\bModules\.([a-zA-Z_][a-zA-Z0-9_]*)': r'modules.\1',
        r'\bModels\.([a-zA-Z_][a-zA-Z0-9_]*)': r'models.\1',
        r'\bTextures\.([a-zA-Z_][a-zA-Z0-9_]*)': r'textures.\1',
        r'\bSounds\.([a-zA-Z_][a-zA-Z0-9_]*)': r'sounds.\1',
        r'\bData\.([a-zA-Z_][a-zA-Z0-9_]*)': r'data.\1',
        r'\bOther\.([a-zA-Z_][a-zA-Z0-9_]*)': r'other.\1',
    }
    for pattern, repl in replacements.items():
        code = re.sub(pattern, repl, code)
    return code

# Unpack module code
def unpack_lua_module(code):
    print("Unpacking module...")
    lines = code.strip().splitlines()
    output_lines = []
    module_name = None

    for i, line in enumerate(lines):
        stripped = line.strip()

        match = re.match(r'^local\s+(\w+)\s*=\s*{}\s*$', stripped)
        if match:
            module_name = match.group(1)
            output_lines.append(f"{module_name} = {{}}")
            continue

        output_lines.append(line)

    if module_name and output_lines[-1].strip() == f"return {module_name}":
        output_lines = output_lines[:-1]

    return "\n".join(output_lines).strip()

def find_matching_end(code, start_index):
    pattern = re.compile(r'\bfunction\b|\bend\b')
    balance = 1
    index = start_index

    for match in pattern.finditer(code, pos=start_index):
        if match.group() == 'function':
            balance += 1
        elif match.group() == 'end':
            balance -= 1

        if balance == 0:
            return match.end()

    raise ValueError("Matching 'end' not found for function starting at index {}".format(start_index))

def extract_function_body(code, func_name):
    pattern = re.compile(rf'{func_name}\s*=\s*function\s*\([^)]*\)')
    match = pattern.search(code)
    if not match:
        return ""
    
    start_pos = match.end()
    lines = code[start_pos:].splitlines()
    
    body_lines = []
    balance = 1
    for line in lines:
        balance += line.count("function")
        balance -= line.count("end")
        body_lines.append(line)
        if balance == 0:
            if body_lines[-1].strip() == "end":
                body_lines.pop()
            break

    return "\n".join(body_lines).rstrip()

def extract_onstart_content(code):
    print("Extracting _ON_START function content...")
    pattern = r'_ON_START\s*=\s*function\s*\([^)]*\)\s*'
    match = re.search(pattern, code)
    if not match:
        return ""

    start_idx = match.end()
    end_idx = find_matching_end(code, start_idx)
    body = code[start_idx:end_idx].strip()

    # Удалить последний `end`, если он есть
    lines = body.splitlines()
    if lines and lines[-1].strip() == "end":
        lines = lines[:-1]
    return "\n".join(lines).strip()


def extract_onstart_client_content(code):
    print("Extracting _ON_START_CLIENT function content...")
    return extract_function_body(code, "_ON_START_CLIENT")

# Generate build file
def generate_build(modules, assets, main_code, github_base_url, module_sources):
    print("Generating build file...")
    out = []

    out.append("-- build.lua autogenerated")
    out.append("_debug = true\n")

    out.append("Client.Tick = function(dt)")
    out.append("    _DELTATIME = dt")
    out.append("    _DT = dt*60 -- multiplier to fix issues with low fps")
    out.append("end\n")

    out.append("Client.OnStart = function()")

    client_start_content = extract_onstart_client_content(main_code)
    if client_start_content:
        indented_client = "\n".join("    " + line.lstrip() for line in client_start_content.split("\n"))
        out.append(indented_client)
    out.append("end\n")


    for group in assets:
        out.append(f"{group} = {{}}\n")
    
    # Add modules
    print("Inserting modules...")
    out.append("-- modules\n")
    for mod_name, mod_code in module_sources.items():
        unpacked = unpack_lua_module(mod_code)
        out.append(unpacked + "\n")

    out.append("local to_load = 0 \nlocal loaded = 0\n")
    out.append("function _log(msg) debug.log(msg) loading_screen.loading_text_update(msg) end")
    out.append("function _check_ready() if loaded >= to_load then _log('All assets loaded') _start_game() end end\n")

    # do not load assets on SERVER!!!
    out.append("if IsServer then return end\n")
    # Load 3D models
    print("Loading 3D models...")
    for key, filename in assets["models"].items():
        url = f"{github_base_url}/source/models/{filename}"
        print("Inserting model", key)
        out.append(f"""to_load = to_load + 1
_log("Downloading models/{key}")
HTTP:Get("{url}", function(res)
    if res.StatusCode == 200 then
        Assets:Load(res.Body, function(assets)
            if assets == nil then
                _log("Failed to load model {key}")
                loaded = loaded + 1
                _check_ready()
                return
            end
            for _, asset in ipairs(assets) do
                asset:SetParent(World)
                if models.{key} == nil then
                    models.{key} = {{asset}}
                else
                    models.{key}[#models.{key}+1] = asset
                end
                _log("Downloaded and loaded model {key}")
            end
            loaded = loaded + 1
            _check_ready()
        end, AssetType.AnyObject)
    else
        _log("Failed to download models/{key}: " .. res.StatusCode)
        loaded = loaded + 1
        _check_ready()
    end
end)\n""")

    # Load other assets
    print("Loading other assets...")
    for group in ["textures", "data", "sounds", "other"]:
        for key, filename in assets[group].items():
            url = f"{github_base_url}/source/{group}/{filename}"
            out.append(f"""to_load = to_load + 1
_log("Downloading {group}/{key}")
HTTP:Get("{url}", function(res)
    if res.StatusCode == 200 then
        {group}.{key} = res.Body
        _log("Downloaded {group}/{key}")
    else
        _log("Failed to download {group}/{key}: " .. res.StatusCode)
    end
    loaded = loaded + 1
    _check_ready()
end)\n""")

    # Add start function
    out.append("-- start\n")
    out.append("function _start_game()")
    onstart_content = extract_onstart_content(main_code)
    if onstart_content:
        # Indent the content properly with 4 spaces
        indented_content = "\n".join("    " + line.lstrip() for line in onstart_content.split("\n"))
        out.append(indented_content)
    else:
        out.append("    worldgen.test()")
    out.append("end\n")
    
    return "\n".join(out)

# Build project
def build_project(source_dir, output_file, github_base_url):
    print("Building project...")
    assets = {"models": {}, "textures": {}, "data": {}, "sounds": {}, "other": {}}
    module_sources = {}
    main_code = ""

    for root, dirs, files in os.walk(source_dir):
        for file in files:
            file_path = os.path.join(root, file)
            rel_path = os.path.relpath(file_path, source_dir)

            if file == "main.lua":
                with open(file_path, 'r', encoding='utf-8') as f:
                    main_code = f.read()
            elif file.endswith(".lua") and "modules" in root:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                mod_name = file.replace(".lua", "")
                module_sources[mod_name] = content
            elif file.endswith(".json"):
                with open(file_path, 'r', encoding='utf-8') as f:
                    f.read()  # Check if file is readable
                assets["data"][file.replace(".json", "")] = file
            elif file.endswith(".glb"):
                assets["models"][file.replace(".glb", "")] = file
            elif file.endswith(".png") or file.endswith(".jpg"):
                assets["textures"][file.rsplit('.', 1)[0]] = file
            elif file.endswith(".mp3"):
                assets["sounds"][file.replace(".mp3", "")] = file
            else:
            # everything else will be saved in other table
                if "other" in root:
                    key = os.path.splitext(file)[0]
                    assets["other"][key] = file

    build_code = generate_build({}, assets, main_code, github_base_url, module_sources)
    # add a random 8 number to the end of the file name to prevent overwriting
    build_code += "\n-- hash: " + str(random.randint(100000000, 999999999))
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(build_code)
    return output_file

# Test parameters
source_directory = "source"
output_file = "build/build.lua"

# IMPORTANT
# Make sure to update the github_base_url to the correct branch, repository, and path.
github_base_url = "https://raw.githubusercontent.com/Nanskip/convy-2/refs/heads/main"

build_project(source_directory, output_file, github_base_url)
print("Done.")
